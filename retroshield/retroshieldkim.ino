////////////////////////////////////////////////////////////////////
// RetroShield 6502 for Arduino Mega
// KIM I
//
// 2019/04/25
// Version 0.1

// The MIT License (MIT)

// Copyright (c) 2019 Erturk Kocalar, 8Bitforce.com

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


////////////////////////////////////////////////////////////////////
// include the library code for LCD shield:
////////////////////////////////////////////////////////////////////

#include <LiquidCrystal.h>
#include <avr/pgmspace.h>

// Set this to enable outputing ADDR, DATA, Freq
// on LCD and use UP/DOWN for controlling RESET#.
#define USE_LCDKEYPAD 1

// Set this to output memory operations during timer clock.
// warning: this will slow down the timer interrupt, so adjust clock
//          freq accordingly.
#define outputDEBUG 0

////////////////////////////////////////////////////////////////////
// Configuration
////////////////////////////////////////////////////////////////////

/*
  The circuit:
 * LCD RS pin to digital pin 12
 * LCD Enable pin to digital pin 11
 * LCD D4 pin to digital pin 5
 * LCD D5 pin to digital pin 4
 * LCD D6 pin to digital pin 3
 * LCD D7 pin to digital pin 2
 * LCD R/W pin to ground
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)
*/

#define LCD_RS  8
#define LCD_EN  9
#define LCD_D4  4
#define LCD_D5  5
#define LCD_D6  6
#define LCD_D7  7
#define LCD_BL  10
#define LCD_BTN  0

#define NUM_KEYS   5
#define BTN_DEBOUNCE 10
#define BTN_RIGHT  0
#define BTN_UP     1
#define BTN_DOWN   2
#define BTN_LEFT   3
#define BTN_SELECT 4
const int adc_key_val[NUM_KEYS] = { 30, 180, 360, 535, 760 };
int       key = -1;
int       oldkey = -1;
boolean   BTN_PRESS = 0;
boolean   BTN_RELEASE = 0;

////////////////////////////////////////////////////////////////////
// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(LCD_RS, LCD_EN, LCD_D4, LCD_D5, LCD_D6, LCD_D7);


////////////////////////////////////////////////////////////////////
// My Variables
////////////////////////////////////////////////////////////////////

int backlightSet = 25;

////////////////////////////////////////////////////////////////////
// 65C02 DEFINITIONS
////////////////////////////////////////////////////////////////////

// 65C02 HW CONSTRAINTS
// 1- RESET_N must be asserted at least 2 clock cycles.
// 2- CLK can not be low more than 5 microseconds.  Can be high indefinitely.
//

// KIM-1 details and some emulation code ported, permission from Oscar
// http://obsolescenceguaranteed.blogspot.com/2014/07/making-modern-low-cost-kim-1-board.html
//

//Overview of memory map:
// main 1KB RAM                               0x000-0x3FF
// available for 4K RAM expansion             0x0400-13FF
// I/O and timer of 6530-003, free for user   0x1700-0x173F
// I/O and timer of 6530-002, used by KIM     0x1740-0x177F
// RAM from 6530-003                          0x1780-0x17BF, free for user
// RAM from 6530-002                          0x17C0-0x17FF, free for user except 0x17E7-0x17FF
// rom003 is                                  0x1800-0x1BFF
// rom002 is                                  0x1C00-0x1FFF

// note that above 8K map is replicated 8 times to fill 64K, and that rom002 contains used addresses for:
//               FFFA, FFFB - NMI Vector
//               FFFC, FFFD - RST Vector
//               FFFE, FFFF - IRQ Vector
// --> so emulator should mirror the 8K memory map at least to the upper 8K block.

// Keyboard/LED(1) or TTY(0).
// If we decide to support LED/Keyboard in the future...
#define USE_KEYBOARD_LED 0

// MEMORY LAYOUT
// 1K + 4K MEMORY
#define RAM_START   0x0000
#define RAM_END     0x13FF
byte    RAM[RAM_END-RAM_START+1];

// 6530-003 I/O and timer of, free for user 0x1700-0x173F

// 6530-003 RAM, 64 bytes
#define RAM003_START   0x1780
#define RAM003_END     0x17BF
byte    RAM003[RAM003_END-RAM003_START+1];

// I/O and timer of 6530-002, free for user 0x1740-0x177F

// 6530-002 RAM, 64 bytes
#define RAM002_START   0x17C0
#define RAM002_END     0x17FF
byte    RAM002[RAM002_END-RAM002_START+1];

// ROMs (Monitor + Basic)
#define ROM003_START   0x1800
#define ROM003_END     0x1BFF
#define ROM002_START   0x1C00
#define ROM002_END     0x1FFF

////////////////////////////////////////////////////////////////////
// Monitor Code
////////////////////////////////////////////////////////////////////

// 6530-003 ROM, 0x1800-0x1BFF
PROGMEM const unsigned char rom003_bin[] = {
	0xA9, 0xAD, 0x8D, 0xEC, 0x17, 0x20, 0x32, 0x19, 0xA9, 0x27, 0x8D, 0x42,
	0x17, 0xA9, 0xBF, 0x8D, 0x43, 0x17, 0xA2, 0x64, 0xA9, 0x16, 0x20, 0x7A,
	0x19, 0xCA, 0xD0, 0xF8, 0xA9, 0x2A, 0x20, 0x7A, 0x19, 0xAD, 0xF9, 0x17,
	0x20, 0x61, 0x19, 0xAD, 0xF5, 0x17, 0x20, 0x5E, 0x19, 0xAD, 0xF6, 0x17,
	0x20, 0x5E, 0x19, 0xAD, 0xED, 0x17, 0xCD, 0xF7, 0x17, 0xAD, 0xEE, 0x17,
	0xED, 0xF8, 0x17, 0x90, 0x24, 0xA9, 0x2F, 0x20, 0x7A, 0x19, 0xAD, 0xE7,
	0x17, 0x20, 0x61, 0x19, 0xAD, 0xE8, 0x17, 0x20, 0x61, 0x19, 0xA2, 0x02,
	0xA9, 0x04, 0x20, 0x7A, 0x19, 0xCA, 0xD0, 0xF8, 0xA9, 0x00, 0x85, 0xFA,
	0x85, 0xFB, 0x4C, 0x4F, 0x1C, 0x20, 0xEC, 0x17, 0x20, 0x5E, 0x19, 0x20,
	0xEA, 0x19, 0x4C, 0x33, 0x18, 0x0F, 0x19, 0xA9, 0x8D, 0x8D, 0xEC, 0x17,
	0x20, 0x32, 0x19, 0xA9, 0x4C, 0x8D, 0xEF, 0x17, 0xAD, 0x71, 0x18, 0x8D,
	0xF0, 0x17, 0xAD, 0x72, 0x18, 0x8D, 0xF1, 0x17, 0xA9, 0x07, 0x8D, 0x42,
	0x17, 0xA9, 0xFF, 0x8D, 0xE9, 0x17, 0x20, 0x41, 0x1A, 0x4E, 0xE9, 0x17,
	0x0D, 0xE9, 0x17, 0x8D, 0xE9, 0x17, 0xAD, 0xE9, 0x17, 0xC9, 0x16, 0xD0,
	0xED, 0xA2, 0x0A, 0x20, 0x24, 0x1A, 0xC9, 0x16, 0xD0, 0xDF, 0xCA, 0xD0,
	0xF6, 0x20, 0x24, 0x1A, 0xC9, 0x2A, 0xF0, 0x06, 0xC9, 0x16, 0xD0, 0xD1,
	0xF0, 0xF3, 0x20, 0xF3, 0x19, 0xCD, 0xF9, 0x17, 0xF0, 0x0D, 0xAD, 0xF9,
	0x17, 0xC9, 0x00, 0xF0, 0x06, 0xC9, 0xFF, 0xF0, 0x17, 0xD0, 0x9C, 0x20,
	0xF3, 0x19, 0x20, 0x4C, 0x19, 0x8D, 0xED, 0x17, 0x20, 0xF3, 0x19, 0x20,
	0x4C, 0x19, 0x8D, 0xEE, 0x17, 0x4C, 0xF8, 0x18, 0x20, 0xF3, 0x19, 0x20,
	0x4C, 0x19, 0x20, 0xF3, 0x19, 0x20, 0x4C, 0x19, 0xA2, 0x02, 0x20, 0x24,
	0x1A, 0xC9, 0x2F, 0xF0, 0x14, 0x20, 0x00, 0x1A, 0xD0, 0x23, 0xCA, 0xD0,
	0xF1, 0x20, 0x4C, 0x19, 0x4C, 0xEC, 0x17, 0x20, 0xEA, 0x19, 0x4C, 0xF8,
	0x18, 0x20, 0xF3, 0x19, 0xCD, 0xE7, 0x17, 0xD0, 0x0C, 0x20, 0xF3, 0x19,
	0xCD, 0xE8, 0x17, 0xD0, 0x04, 0xA9, 0x00, 0xF0, 0x02, 0xA9, 0xFF, 0x85,
	0xFA, 0x85, 0xFB, 0x4C, 0x4F, 0x1C, 0xAD, 0xF5, 0x17, 0x8D, 0xED, 0x17,
	0xAD, 0xF6, 0x17, 0x8D, 0xEE, 0x17, 0xA9, 0x60, 0x8D, 0xEF, 0x17, 0xA9,
	0x00, 0x8D, 0xE7, 0x17, 0x8D, 0xE8, 0x17, 0x60, 0xA8, 0x18, 0x6D, 0xE7,
	0x17, 0x8D, 0xE7, 0x17, 0xAD, 0xE8, 0x17, 0x69, 0x00, 0x8D, 0xE8, 0x17,
	0x98, 0x60, 0x20, 0x4C, 0x19, 0xA8, 0x4A, 0x4A, 0x4A, 0x4A, 0x20, 0x6F,
	0x19, 0x98, 0x20, 0x6F, 0x19, 0x98, 0x60, 0x29, 0x0F, 0xC9, 0x0A, 0x18,
	0x30, 0x02, 0x69, 0x07, 0x69, 0x30, 0x8E, 0xE9, 0x17, 0x8C, 0xEA, 0x17,
	0xA0, 0x08, 0x20, 0x9E, 0x19, 0x4A, 0xB0, 0x06, 0x20, 0x9E, 0x19, 0x4C,
	0x91, 0x19, 0x20, 0xC4, 0x19, 0x20, 0xC4, 0x19, 0x88, 0xD0, 0xEB, 0xAE,
	0xE9, 0x17, 0xAC, 0xEA, 0x17, 0x60, 0xA2, 0x09, 0x48, 0x2C, 0x47, 0x17,
	0x10, 0xFB, 0xA9, 0x7E, 0x8D, 0x44, 0x17, 0xA9, 0xA7, 0x8D, 0x42, 0x17,
	0x2C, 0x47, 0x17, 0x10, 0xFB, 0xA9, 0x7E, 0x8D, 0x44, 0x17, 0xA9, 0x27,
	0x8D, 0x42, 0x17, 0xCA, 0xD0, 0xDF, 0x68, 0x60, 0xA2, 0x06, 0x48, 0x2C,
	0x47, 0x17, 0x10, 0xFB, 0xA9, 0xC3, 0x8D, 0x44, 0x17, 0xA9, 0xA7, 0x8D,
	0x42, 0x17, 0x2C, 0x47, 0x17, 0x10, 0xFB, 0xA9, 0xC3, 0x8D, 0x44, 0x17,
	0xA9, 0x27, 0x8D, 0x42, 0x17, 0xCA, 0xD0, 0xDF, 0x68, 0x60, 0xEE, 0xED,
	0x17, 0xD0, 0x03, 0xEE, 0xEE, 0x17, 0x60, 0x20, 0x24, 0x1A, 0x20, 0x00,
	0x1A, 0x20, 0x24, 0x1A, 0x20, 0x00, 0x1A, 0x60, 0xC9, 0x30, 0x30, 0x1E,
	0xC9, 0x47, 0x10, 0x1A, 0xC9, 0x40, 0x30, 0x03, 0x18, 0x69, 0x09, 0x2A,
	0x2A, 0x2A, 0x2A, 0xA0, 0x04, 0x2A, 0x2E, 0xE9, 0x17, 0x88, 0xD0, 0xF9,
	0xAD, 0xE9, 0x17, 0xA0, 0x00, 0x60, 0xC8, 0x60, 0x8E, 0xEB, 0x17, 0xA2,
	0x08, 0x20, 0x41, 0x1A, 0x4E, 0xEA, 0x17, 0x0D, 0xEA, 0x17, 0x8D, 0xEA,
	0x17, 0xCA, 0xD0, 0xF1, 0xAD, 0xEA, 0x17, 0x2A, 0x4A, 0xAE, 0xEB, 0x17,
	0x60, 0x2C, 0x42, 0x17, 0x10, 0xFB, 0xAD, 0x46, 0x17, 0xA0, 0xFF, 0x8C,
	0x46, 0x17, 0xA0, 0x14, 0x88, 0xD0, 0xFD, 0x2C, 0x42, 0x17, 0x30, 0xFB,
	0x38, 0xED, 0x46, 0x17, 0xA0, 0xFF, 0x8C, 0x46, 0x17, 0xA0, 0x07, 0x88,
	0xD0, 0xFD, 0x49, 0xFF, 0x29, 0x80, 0x60, 0xA9, 0x27, 0x8D, 0x42, 0x17,
	0xA9, 0xBF, 0x8D, 0x43, 0x17, 0x2C, 0x47, 0x17, 0x10, 0xFB, 0xA9, 0x9A,
	0x8D, 0x44, 0x17, 0xA9, 0xA7, 0x8D, 0x42, 0x17, 0x2C, 0x47, 0x17, 0x10,
	0xFB, 0xA9, 0x9A, 0x8D, 0x44, 0x17, 0xA9, 0x27, 0x8D, 0x42, 0x17, 0x4C,
	0x75, 0x1A, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x6B, 0x1A,
	0x6B, 0x1A, 0x6B, 0x1A
};

// 6530-002 ROM, 0x1C00-0x1FFF

// PROGMEM const unsigned char rom002_bin[] = { 
byte rom002_bin[] = {   
	0x85, 0xF3, 0x68, 0x85, 0xF1, 0x68, 0x85, 0xEF, 0x85, 0xFA, 0x68, 0x85,
	0xF0, 0x85, 0xFB, 0x84, 0xF4, 0x86, 0xF5, 0xBA, 0x86, 0xF2, 0x20, 0x88,
	0x1E, 0x4C, 0x4F, 0x1C, 0x6C, 0xFA, 0x17, 0x6C, 0xFE, 0x17, 0xA2, 0xFF,
	0x9A, 0x86, 0xF2, 0x20, 0x88, 0x1E, 0xA9, 0xFF, 0x8D, 0xF3, 0x17, 0xA9,
	0x01, 0x2C, 0x40, 0x17, 0xD0, 0x19, 0x30, 0xF9, 0xA9, 0xFC, 0x18, 0x69,
	0x01, 0x90, 0x03, 0xEE, 0xF3, 0x17, 0xAC, 0x40, 0x17, 0x10, 0xF3, 0x8D,
	0xF2, 0x17, 0xA2, 0x08, 0x20, 0x6A, 0x1E, 0x20, 0x8C, 0x1E, 0xA9, 0x01,
	0x2C, 0x40, 0x17, 0xD0, 0x1E, 0x20, 0x2F, 0x1E, 0xA2, 0x0A, 0x20, 0x31,
	0x1E, 0x4C, 0xAF, 0x1D, 0xA9, 0x00, 0x85, 0xF8, 0x85, 0xF9, 0x20, 0x5A,
	0x1E, 0xC9, 0x01, 0xF0, 0x06, 0x20, 0xAC, 0x1F, 0x4C, 0xDB, 0x1D, 0x20,
	0x19, 0x1F, 0xD0, 0xD3, 0xA9, 0x01, 0x2C, 0x40, 0x17, 0xF0, 0xCC, 0x20,
	0x19, 0x1F, 0xF0, 0xF4, 0x20, 0x19, 0x1F, 0xF0, 0xEF, 0x20, 0x6A, 0x1F,
	0xC9, 0x15, 0x10, 0xBB, 0xC9, 0x14, 0xF0, 0x44, 0xC9, 0x10, 0xF0, 0x2C,
	0xC9, 0x11, 0xF0, 0x2C, 0xC9, 0x12, 0xF0, 0x2F, 0xC9, 0x13, 0xF0, 0x31,
	0x0A, 0x0A, 0x0A, 0x0A, 0x85, 0xFC, 0xA2, 0x04, 0xA4, 0xFF, 0xD0, 0x0A,
	0xB1, 0xFA, 0x06, 0xFC, 0x2A, 0x91, 0xFA, 0x4C, 0xC3, 0x1C, 0x0A, 0x26,
	0xFA, 0x26, 0xFB, 0xCA, 0xD0, 0xEA, 0xF0, 0x08, 0xA9, 0x01, 0xD0, 0x02,
	0xA9, 0x00, 0x85, 0xFF, 0x4C, 0x4F, 0x1C, 0x20, 0x63, 0x1F, 0x4C, 0x4F,
	0x1C, 0x4C, 0xC8, 0x1D, 0xA5, 0xEF, 0x85, 0xFA, 0xA5, 0xF0, 0x85, 0xFB,
	0x4C, 0x4F, 0x1C, 0x20, 0x5A, 0x1E, 0xC9, 0x3B, 0xD0, 0xF9, 0xA9, 0x00,
	0x85, 0xF7, 0x85, 0xF6, 0x20, 0x9D, 0x1F, 0xAA, 0x20, 0x91, 0x1F, 0x20,
	0x9D, 0x1F, 0x85, 0xFB, 0x20, 0x91, 0x1F, 0x20, 0x9D, 0x1F, 0x85, 0xFA,
	0x20, 0x91, 0x1F, 0x8A, 0xF0, 0x0F, 0x20, 0x9D, 0x1F, 0x91, 0xFA, 0x20,
	0x91, 0x1F, 0x20, 0x63, 0x1F, 0xCA, 0xD0, 0xF2, 0xE8, 0x20, 0x9D, 0x1F,
	0xC5, 0xF6, 0xD0, 0x17, 0x20, 0x9D, 0x1F, 0xC5, 0xF7, 0xD0, 0x13, 0x8A,
	0xD0, 0xB9, 0xA2, 0x0C, 0xA9, 0x27, 0x8D, 0x42, 0x17, 0x20, 0x31, 0x1E,
	0x4C, 0x4F, 0x1C, 0x20, 0x9D, 0x1F, 0xA2, 0x11, 0xD0, 0xEE, 0xA9, 0x00,
	0x85, 0xF8, 0x85, 0xF9, 0xA9, 0x00, 0x85, 0xF6, 0x85, 0xF7, 0x20, 0x2F,
	0x1E, 0xA9, 0x3B, 0x20, 0xA0, 0x1E, 0xA5, 0xFA, 0xCD, 0xF7, 0x17, 0xA5,
	0xFB, 0xED, 0xF8, 0x17, 0x90, 0x18, 0xA9, 0x00, 0x20, 0x3B, 0x1E, 0x20,
	0xCC, 0x1F, 0x20, 0x1E, 0x1E, 0xA5, 0xF6, 0x20, 0x3B, 0x1E, 0xA5, 0xF7,
	0x20, 0x3B, 0x1E, 0x4C, 0x64, 0x1C, 0xA9, 0x18, 0xAA, 0x20, 0x3B, 0x1E,
	0x20, 0x91, 0x1F, 0x20, 0x1E, 0x1E, 0xA0, 0x00, 0xB1, 0xFA, 0x20, 0x3B,
	0x1E, 0x20, 0x91, 0x1F, 0x20, 0x63, 0x1F, 0xCA, 0xD0, 0xF0, 0xA5, 0xF6,
	0x20, 0x3B, 0x1E, 0xA5, 0xF7, 0x20, 0x3B, 0x1E, 0xE6, 0xF8, 0xD0, 0x02,
	0xE6, 0xF9, 0x4C, 0x48, 0x1D, 0x20, 0xCC, 0x1F, 0x20, 0x2F, 0x1E, 0x20,
	0x1E, 0x1E, 0x20, 0x9E, 0x1E, 0xA0, 0x00, 0xB1, 0xFA, 0x20, 0x3B, 0x1E,
	0x20, 0x9E, 0x1E, 0x4C, 0x64, 0x1C, 0x20, 0x63, 0x1F, 0x4C, 0xAC, 0x1D,
	0xA6, 0xF2, 0x9A, 0xA5, 0xFB, 0x48, 0xA5, 0xFA, 0x48, 0xA5, 0xF1, 0x48,
	0xA6, 0xF5, 0xA4, 0xF4, 0xA5, 0xF3, 0x40, 0xC9, 0x20, 0xF0, 0xCA, 0xC9,
	0x7F, 0xF0, 0x1B, 0xC9, 0x0D, 0xF0, 0xDB, 0xC9, 0x0A, 0xF0, 0x1C, 0xC9,
	0x2E, 0xF0, 0x26, 0xC9, 0x47, 0xF0, 0xD5, 0xC9, 0x51, 0xF0, 0x0A, 0xC9,
	0x4C, 0xF0, 0x09, 0x4C, 0x6A, 0x1C, 0x4C, 0x4F, 0x1C, 0x4C, 0x42, 0x1D,
	0x4C, 0xE7, 0x1C, 0x38, 0xA5, 0xFA, 0xE9, 0x01, 0x85, 0xFA, 0xB0, 0x02,
	0xC6, 0xFB, 0x4C, 0xAC, 0x1D, 0xA0, 0x00, 0xA5, 0xF8, 0x91, 0xFA, 0x4C,
	0xC2, 0x1D, 0xA5, 0xFB, 0x20, 0x3B, 0x1E, 0x20, 0x91, 0x1F, 0xA5, 0xFA,
	0x20, 0x3B, 0x1E, 0x20, 0x91, 0x1F, 0x60, 0xA2, 0x07, 0xBD, 0xD5, 0x1F,
	0x20, 0xA0, 0x1E, 0xCA, 0x10, 0xF7, 0x60, 0x85, 0xFC, 0x4A, 0x4A, 0x4A,
	0x4A, 0x20, 0x4C, 0x1E, 0xA5, 0xFC, 0x20, 0x4C, 0x1E, 0xA5, 0xFC, 0x60,
	0x29, 0x0F, 0xC9, 0x0A, 0x18, 0x30, 0x02, 0x69, 0x07, 0x69, 0x30, 0x4C,
	0xA0, 0x1E, 0x86, 0xFD, 0xA2, 0x08, 0xA9, 0x01, 0x2C, 0x40, 0x17, 0xD0,
	0x22, 0x30, 0xF9, 0x20, 0xD4, 0x1E, 0x20, 0xEB, 0x1E, 0xAD, 0x40, 0x17,
	0x29, 0x80, 0x46, 0xFE, 0x05, 0xFE, 0x85, 0xFE, 0x20, 0xD4, 0x1E, 0xCA,
	0xD0, 0xEF, 0x20, 0xEB, 0x1E, 0xA6, 0xFD, 0xA5, 0xFE, 0x2A, 0x4A, 0x60,
	0xA2, 0x01, 0x86, 0xFF, 0xA2, 0x00, 0x8E, 0x41, 0x17, 0xA2, 0x3F, 0x8E,
	0x43, 0x17, 0xA2, 0x07, 0x8E, 0x42, 0x17, 0xD8, 0x78, 0x60, 0xA9, 0x20,
	0x85, 0xFE, 0x86, 0xFD, 0x20, 0xD4, 0x1E, 0xAD, 0x42, 0x17, 0x29, 0xFE,
	0x8D, 0x42, 0x17, 0x20, 0xD4, 0x1E, 0xA2, 0x08, 0xAD, 0x42, 0x17, 0x29,
	0xFE, 0x46, 0xFE, 0x69, 0x00, 0x8D, 0x42, 0x17, 0x20, 0xD4, 0x1E, 0xCA,
	0xD0, 0xEE, 0xAD, 0x42, 0x17, 0x09, 0x01, 0x8D, 0x42, 0x17, 0x20, 0xD4,
	0x1E, 0xA6, 0xFD, 0x60, 0xAD, 0xF3, 0x17, 0x8D, 0xF4, 0x17, 0xAD, 0xF2,
	0x17, 0x38, 0xE9, 0x01, 0xB0, 0x03, 0xCE, 0xF4, 0x17, 0xAC, 0xF4, 0x17,
	0x10, 0xF3, 0x60, 0xAD, 0xF3, 0x17, 0x8D, 0xF4, 0x17, 0xAD, 0xF2, 0x17,
	0x4A, 0x4E, 0xF4, 0x17, 0x90, 0xE3, 0x09, 0x80, 0xB0, 0xE0, 0xA0, 0x03,
	0xA2, 0x01, 0xA9, 0xFF, 0x8E, 0x42, 0x17, 0xE8, 0xE8, 0x2D, 0x40, 0x17,
	0x88, 0xD0, 0xF5, 0xA0, 0x07, 0x8C, 0x42, 0x17, 0x09, 0x80, 0x49, 0xFF,
	0x60, 0xA0, 0x00, 0xB1, 0xFA, 0x85, 0xF9, 0xA9, 0x7F, 0x8D, 0x41, 0x17,
	0xA2, 0x09, 0xA0, 0x03, 0xB9, 0xF8, 0x00, 0x4A, 0x4A, 0x4A, 0x4A, 0x20,
	0x48, 0x1F, 0xB9, 0xF8, 0x00, 0x29, 0x0F, 0x20, 0x48, 0x1F, 0x88, 0xD0,
	0xEB, 0x8E, 0x42, 0x17, 0xA9, 0x00, 0x8D, 0x41, 0x17, 0x4C, 0xFE, 0x1E,
	0x84, 0xFC, 0xA8, 0xB9, 0xE7, 0x1F, 0xA0, 0x00, 0x8C, 0x40, 0x17, 0x8E,
	0x42, 0x17, 0x8D, 0x40, 0x17, 0xA0, 0x7F, 0x88, 0xD0, 0xFD, 0xE8, 0xE8,
	0xA4, 0xFC, 0x60, 0xE6, 0xFA, 0xD0, 0x02, 0xE6, 0xFB, 0x60, 0xA2, 0x21,
	0xA0, 0x01, 0x20, 0x02, 0x1F, 0xD0, 0x07, 0xE0, 0x27, 0xD0, 0xF5, 0xA9,
	0x15, 0x60, 0xA0, 0xFF, 0x0A, 0xB0, 0x03, 0xC8, 0x10, 0xFA, 0x8A, 0x29,
	0x0F, 0x4A, 0xAA, 0x98, 0x10, 0x03, 0x18, 0x69, 0x07, 0xCA, 0xD0, 0xFA,
	0x60, 0x18, 0x65, 0xF7, 0x85, 0xF7, 0xA5, 0xF6, 0x69, 0x00, 0x85, 0xF6,
	0x60, 0x20, 0x5A, 0x1E, 0x20, 0xAC, 0x1F, 0x20, 0x5A, 0x1E, 0x20, 0xAC,
	0x1F, 0xA5, 0xF8, 0x60, 0xC9, 0x30, 0x30, 0x1B, 0xC9, 0x47, 0x10, 0x17,
	0xC9, 0x40, 0x30, 0x03, 0x18, 0x69, 0x09, 0x2A, 0x2A, 0x2A, 0x2A, 0xA0,
	0x04, 0x2A, 0x26, 0xF8, 0x26, 0xF9, 0x88, 0xD0, 0xF8, 0xA9, 0x00, 0x60,
	0xA5, 0xF8, 0x85, 0xFA, 0xA5, 0xF9, 0x85, 0xFB, 0x60, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0A, 0x0D, 0x4D, 0x49, 0x4B, 0x20, 0x13, 0x52, 0x52,
	0x45, 0x20, 0x13, 0xBF, 0x86, 0xDB, 0xCF, 0xE6, 0xED, 0xFD, 0x87, 0xFF,
	0xEF, 0xF7, 0xFC, 0xB9, 0xDE, 0xF9, 0xF1, 0xFF, 0xFF, 0xFF, 0x1C, 0x1C,
	0x22, 0x1C, 0x1F, 0x1C
};

////////////////////////////////////////////////////////////////////
// 6530 Registers
////////////////////////////////////////////////////////////////////

// set this to 1 to use keyboard/display (NOT SUPPORTED)
#define USE_KEYBOARD_DISPLAY 0

byte reg002_A;
byte reg002_DIRA;
byte reg002_B;
byte reg002_DIRB;
byte reg002_CLKRDI;
byte reg002_CLKRDT;
byte reg002_ENABLE_IRQ;
word reg002_TIMER_TICK;
word reg002_INT_TIMER;

byte reg003_A;
byte reg003_DIRA;
byte reg003_B;
byte reg003_DIRB;
byte reg003_CLKRDI;
byte reg003_CLKRDT;
byte reg003_ENABLE_IRQ;
word reg003_TIMER_TICK;
word reg003_INT_TIMER;

#define CLK1T     1
#define CLK8T     8
#define CLK64T    64
#define CLK1024T  1024


////////////////////////////////////////////////////////////////////
// 65c02 Processor Control
////////////////////////////////////////////////////////////////////
//

/* Digital Pin Assignments */
#define DATA_OUT PORTL
#define DATA_IN  PINL
#define ADDR_H   PINC
#define ADDR_L   PINA
#define ADDR     ((unsigned int) (ADDR_H << 8 | ADDR_L))

#define uP_RESET_N  38
#define uP_RW_N     40
#define uP_RDY      39
#define uP_SO_N     41
#define uP_IRQ_N    50
#define uP_NMI_N    51
#define uP_E        52
#define uP_GPIO     53

// Fast routines to drive clock signals high/low; faster than digitalWrite
// required to meet >100kHz clock freq for 6809e.
// 6502 & z80 do not have this requirement.
//
#define CLK_Q_HIGH  (PORTB = PORTB | 0x01)
#define CLK_Q_LOW   (PORTB = PORTB & 0xFE)
#define CLK_E_HIGH  (PORTB = PORTB | 0x02)
#define CLK_E_LOW   (PORTB = PORTB & 0xFD)
#define STATE_RW_N  (PING & 0x02)

#define DIR_IN  0x00
#define DIR_OUT 0xFF
#define DATA_DIR   DDRL
#define ADDR_H_DIR DDRC
#define ADDR_L_DIR DDRA

unsigned long clock_cycle_count;
unsigned long uP_start_millis;
unsigned long uP_stop_millis;
word  uP_ADDR;
byte uP_DATA;

void uP_assert_reset()
{
  // Drive RESET conditions
  digitalWrite(uP_RESET_N, LOW);
  digitalWrite(uP_IRQ_N, HIGH);
  digitalWrite(uP_NMI_N, HIGH);
  digitalWrite(uP_RDY, HIGH);
  digitalWrite(uP_SO_N, HIGH);
}

void uP_release_reset()
{
  // Drive RESET conditions
  digitalWrite(uP_RESET_N, HIGH);
}

void uP_assert_nmi()
{
  // Drive RESET conditions
  digitalWrite(uP_NMI_N, LOW);
}

void uP_release_nmi()
{
  // Drive RESET conditions
  digitalWrite(uP_NMI_N, HIGH);
}

void uP_init()
{
  // Set directions
  DATA_DIR = DIR_IN;
  ADDR_H_DIR = DIR_IN;
  ADDR_L_DIR = DIR_IN;
  pinMode(uP_RESET_N, OUTPUT);
  pinMode(uP_RW_N, INPUT);
  pinMode(uP_RDY, OUTPUT);
  pinMode(uP_SO_N, OUTPUT);
  pinMode(uP_IRQ_N, OUTPUT);
  pinMode(uP_NMI_N, OUTPUT);
  pinMode(uP_E, OUTPUT);
  pinMode(uP_GPIO, OUTPUT);
  
  uP_assert_reset();
  digitalWrite(uP_E, LOW);
  digitalWrite(uP_GPIO, LOW);
  
  clock_cycle_count = 0;
  uP_start_millis = millis();
  // Next State
}


void kim_init() {       
  // Modify ROM to work w/ RetroShield
             
  // this is what user has to enter manually when powering KIM on. Why not do it here.
  RAM002[(0x17FA)-(0x17C0)]=0x00;
  RAM002[(0x17FB)-(0x17C0)]=0x1C;
  RAM002[(0x17FE)-(0x17C0)]=0x00;
  RAM002[(0x17FF)-(0x17C0)]=0x1C;
  
  // Skip TTY timing =====
  // JMP $1C4F    4C 4F 1C
  //
  rom002_bin[(0x1C2A)-(0x1C00)]= 0x4C;
  rom002_bin[(0x1C2B)-(0x1C00)]= 0x4F;
  rom002_bin[(0x1C2C)-(0x1C00)]= 0x1C;

  // skip "1C57 BNE TTYKB" upon NMI/IRQ.
  rom002_bin[(0x1C57)-(0x1C00)]= 0xEA;    // NOP
  rom002_bin[(0x1C58)-(0x1C00)]= 0xEA;    // NOP


  // Modify OUTCH and GETCH to use Arduino Serial Port.
  // OUTCH = write A to reg002_B
  // GETCH = read A from reg002_A (use bit 7 to sync)

  // OUTCH ===============
  // STA $1742    8D 42 17 
  // RTS          60
  rom002_bin[(0x1EA4)-(0x1C00)]= 0x8D;
  rom002_bin[(0x1EA5)-(0x1C00)]= 0x42;
  rom002_bin[(0x1EA6)-(0x1C00)]= 0x17;
  rom002_bin[(0x1EA7)-(0x1C00)]= 0x60;

  // GETCH ===============
  // 1E5C LDY #$FFFF    A0 FF FF        ; for compatibility
  // WAIT LDA $1740     AD 40 17
  //      BPL WAIT      10 FB
  //      AND #$7F      29 7F
  //      STA $1740     8D 40 17
  //      RTS           60

  if (1)
  {
    // rom002_bin[(0x1E5C)-(0x1C00)]= 0xA0;
    // rom002_bin[(0x1E5D)-(0x1C00)]= 0xFF;
    // rom002_bin[(0x1E5E)-(0x1C00)]= 0xFF;    
    rom002_bin[(0x1E5C)-(0x1C00)]= 0xAD;
    rom002_bin[(0x1E5D)-(0x1C00)]= 0x40;
    rom002_bin[(0x1E5E)-(0x1C00)]= 0x17;
    rom002_bin[(0x1E5F)-(0x1C00)]= 0x10;
    rom002_bin[(0x1E60)-(0x1C00)]= 0xFB;
    rom002_bin[(0x1E61)-(0x1C00)]= 0x29;
    rom002_bin[(0x1E62)-(0x1C00)]= 0x7F;
    rom002_bin[(0x1E63)-(0x1C00)]= 0x8D;
    rom002_bin[(0x1E64)-(0x1C00)]= 0x40;
    rom002_bin[(0x1E65)-(0x1C00)]= 0x17;
    rom002_bin[(0x1E66)-(0x1C00)]= 0x60;
  }  
}

inline __attribute__((always_inline))
void r6530_init()
{
  reg002_A      = 0x00 | USE_KEYBOARD_DISPLAY;
  reg002_DIRA   = 0x00;
  reg002_B      = 0x00;
  reg002_DIRB   = 0x00;
  reg002_CLKRDI = 0x00;
  reg002_CLKRDT = 0x00;
  
  reg002_ENABLE_IRQ = 0x00;
  reg002_TIMER_TICK = CLK1T;
  reg002_INT_TIMER  = CLK1T;

  reg003_A      = 0x00;
  reg003_DIRA   = 0x00;
  reg003_B      = 0x00;
  reg003_DIRB   = 0x00;
  reg003_CLKRDI = 0x00;
  reg003_CLKRDT = 0x00;

  reg003_ENABLE_IRQ = 0x00;
  reg003_TIMER_TICK = CLK1T;
  reg003_INT_TIMER  = CLK1T;
}

inline __attribute__((always_inline))
byte r6530_read(word addr)
{
  byte dout;

  byte A3     = addr & 0b1000;
  byte A2A1A0 = addr & 0b0111;

  if (addr >= 0x1740)
  {
    // I/O Timer 002
    if  (A2A1A0 == 0)    dout = reg002_A;
    if  (A2A1A0 == 1)    dout = reg002_DIRA;
    if  (A2A1A0 == 2)    dout = reg002_B;
    if  (A2A1A0 == 3)    dout = reg002_DIRB;
    if ((A2A1A0 == 4) && (A2A1A0 == 6))   { dout = reg002_CLKRDT; reg002_ENABLE_IRQ = A3; }
    if ((A2A1A0 == 5) && (A2A1A0 == 7))     dout = reg002_CLKRDI;

  } else {
    // I/O Timer 003
    if  (A2A1A0 == 0)    dout = reg003_A;
    if  (A2A1A0 == 1)    dout = reg003_DIRA;
    if  (A2A1A0 == 2)    dout = reg003_B;
    if  (A2A1A0 == 3)    dout = reg003_DIRB;
    if ((A2A1A0 == 4) && (A2A1A0 == 6))   { dout = reg003_CLKRDT; reg003_ENABLE_IRQ = A3; }
    if ((A2A1A0 == 5) && (A2A1A0 == 7))     dout = reg003_CLKRDI;
  }

  if (outputDEBUG)
  {
    char tmp[100];
    sprintf(tmp, "      r6530_read(%0.4X) = %0.2X\n", addr, dout);
    Serial.write(tmp);
  }

  return dout;  
}

inline __attribute__((always_inline))
void r6530_write(word addr, byte din)
{
  byte A0     = addr & 0b0001;
  byte A2     = addr & 0b0100;
  byte A3     = addr & 0b1000;
  byte A2A1A0 = addr & 0b0111;

  if (outputDEBUG)
  {
    char tmp[100];
    sprintf(tmp, "      r6530_write(%0.4X, %0.2X)\n", addr, din);
    Serial.write(tmp);
  }

  if (addr >= 0x1740)
  {
    // I/O Timer 002
    if (A2A1A0 == 0)    reg002_A    = din;     // bit 7 used for serial port
    if (A2A1A0 == 1)    reg002_DIRA = din;
    if (A2A1A0 == 2)    { reg002_B    = din; Serial.write(din); }
    if (A2A1A0 == 3)    reg002_DIRB = din;
    // Following will start timer.  save count.  also initialize internal counters.
    if (A2A1A0 == 4)    { reg002_CLKRDT = din; reg002_INT_TIMER=reg002_TIMER_TICK=CLK1T;    reg002_ENABLE_IRQ = A3; }
    if (A2A1A0 == 5)    { reg002_CLKRDT = din; reg002_INT_TIMER=reg002_TIMER_TICK=CLK8T;    reg002_ENABLE_IRQ = A3; }
    if (A2A1A0 == 6)    { reg002_CLKRDT = din; reg002_INT_TIMER=reg002_TIMER_TICK=CLK64T;   reg002_ENABLE_IRQ = A3; }
    if (A2A1A0 == 7)    { reg002_CLKRDT = din; reg002_INT_TIMER=reg002_TIMER_TICK=CLK1024T; reg002_ENABLE_IRQ = A3; }

  } else {
    // I/O Timer 003
    if (A2A1A0 == 0)    reg003_A    = din;
    if (A2A1A0 == 1)    reg003_DIRA = din;
    if (A2A1A0 == 2)    reg003_B    = din;
    if (A2A1A0 == 3)    reg003_DIRB = din;
    // Following will start timer.  save count.  also initialize internal counters.
    if (A2A1A0 == 4)    { reg003_CLKRDT = din; reg003_INT_TIMER=reg003_TIMER_TICK=CLK1T;    reg003_ENABLE_IRQ = A3; }
    if (A2A1A0 == 5)    { reg003_CLKRDT = din; reg003_INT_TIMER=reg003_TIMER_TICK=CLK8T;    reg003_ENABLE_IRQ = A3; }
    if (A2A1A0 == 6)    { reg003_CLKRDT = din; reg003_INT_TIMER=reg003_TIMER_TICK=CLK64T;   reg003_ENABLE_IRQ = A3; }
    if (A2A1A0 == 7)    { reg003_CLKRDT = din; reg003_INT_TIMER=reg003_TIMER_TICK=CLK1024T; reg003_ENABLE_IRQ = A3; }

  }  
}

inline __attribute__((always_inline))
void r6530_timer_tick()
{
  // I/O TIMER 002
  //
  if (reg002_INT_TIMER == 0)
  {
    // This shouldnt happen, so just recover.
    // reload INT_TIMER
    reg002_INT_TIMER = reg002_TIMER_TICK;
    
  } else {
    reg002_INT_TIMER--;

    if (reg002_INT_TIMER == 0)
    {
      reg002_CLKRDT--;

      if (reg002_CLKRDT == 0) {
        // Main timer timed-out:
        reg002_TIMER_TICK = CLK1T;    // reset tick to 1T
        reg002_CLKRDI = 0xFF;         // Set Interrupt Flag
        if (reg002_ENABLE_IRQ != 0)   // Set PB7 if interrupt-enabled
          reg002_B |= 0x80;
      }
    }
  }

  // I/O TIMER 003
  //
  if (reg003_INT_TIMER == 0)
  {
    // This shouldnt happen, so just recover.
    // reload INT_TIMER
    reg003_INT_TIMER = reg003_TIMER_TICK;
    
  } else {
    reg003_INT_TIMER--;

    if (reg003_INT_TIMER == 0)
    {
      reg003_CLKRDT--;

      if (reg003_CLKRDT == 0) {
        // Main timer timed-out:
        reg003_TIMER_TICK = CLK1T;    // reset tick to 1T
        reg003_CLKRDI = 0xFF;         // Set Interrupt Flag
        if (reg003_ENABLE_IRQ != 0)   // Set PB7 if interrupt-enabled
          reg003_B |= 0x80;
      }
    }
  }
}


////////////////////////////////////////////////////////////////////
// Processor Control Loop
////////////////////////////////////////////////////////////////////
// This is where the action is.
// it reads processor control signals and acts accordingly.
//
ISR(TIMER1_COMPA_vect)
{ 
  CLK_E_HIGH;    // E goes high   // digitalWrite(uP_E, HIGH);

  // Ignore the top 3 bits of address bus (memory map replicated 8 times)
  uP_ADDR = ADDR & 0b0001111111111111;
  
  
  if (STATE_RW_N)	  
  //////////////////////////////////////////////////////////////////
  // HIGH = READ
  {
    // change DATA port to output to uP:
    DATA_DIR = DIR_OUT;

    // Order the comparison from low to high memory for optimizations
    
    // ROM?
    if ( (ROM003_START <= uP_ADDR) && (uP_ADDR <= ROM003_END) )
      DATA_OUT = pgm_read_byte_near(rom003_bin + (uP_ADDR - ROM003_START));
    else
    if ( (ROM002_START <= uP_ADDR) && (uP_ADDR <= ROM002_END) )
      DATA_OUT = rom002_bin [(uP_ADDR - ROM002_START)];         // we modify ROM002
    else
    // RAM?
    if ( (uP_ADDR <= RAM_END) && (RAM_START <= uP_ADDR) )
      DATA_OUT = RAM[uP_ADDR - RAM_START];
    else
    // RAM002?
    if ( (uP_ADDR <= RAM002_END) && (RAM002_START <= uP_ADDR) )
      DATA_OUT = RAM002[uP_ADDR - RAM002_START];
    else
    // RAM003?
    if ( (uP_ADDR <= RAM003_END) && (RAM003_START <= uP_ADDR) )
      DATA_OUT = RAM003[uP_ADDR - RAM003_START];
    else
    // I/O Timer 003, I/O Timer 002
    if ( (uP_ADDR >= 0x1700) && (uP_ADDR <= 0x177F) )
      DATA_OUT = r6530_read(uP_ADDR);

    // I/O and timer of 6530-003, free for user   0x1700-0x173F
    // I/O and timer of 6530-002, used by KIM     0x1740-0x177F


#if (outputDEBUG)
    {
      char tmp[100];
      sprintf(tmp, "-- A=%0.4X D=%0.2X      %0.4X/%0.4X   %0.4X/%0.4X\n", 
        uP_ADDR, DATA_OUT,
        reg002_INT_TIMER, reg002_CLKRDT,
        reg003_INT_TIMER, reg003_CLKRDT);
      Serial.write(tmp);
    }
#endif

  } 
  else 
  //////////////////////////////////////////////////////////////////
  // R/W = LOW = WRITE
  {
    // RAM?
    if ( (uP_ADDR <= RAM_END) && (RAM_START <= uP_ADDR) )
      RAM[uP_ADDR - RAM_START] = DATA_IN;
    else
    // RAM002?
    if ( (uP_ADDR <= RAM002_END) && (RAM002_START <= uP_ADDR) )
      RAM002[uP_ADDR - RAM002_START] = DATA_IN;
    else
    // RAM003?
    if ( (uP_ADDR <= RAM003_END) && (RAM003_START <= uP_ADDR) )
      RAM002[uP_ADDR - RAM003_START] = DATA_IN;
    else
    // I/O Timer 003
    if ( (uP_ADDR >= 0x1700) && (uP_ADDR <= 0x177F) )
      r6530_write(uP_ADDR, DATA_IN);
      
#if (outputDEBUG)
    {
      char tmp[100];
      sprintf(tmp, "WR A=%0.4X D=%0.2X      %0.4X/%0.4X   %0.4X/%0.4X\n", 
        uP_ADDR, DATA_IN, 
        reg002_INT_TIMER, reg002_CLKRDT,
        reg003_INT_TIMER, reg003_CLKRDT);
      Serial.write(tmp);
    }
#endif

  }

  //////////////////////////////////////////////////////////////////
#if (USE_LCDKEYPAD)
  // one full cycle complete
  clock_cycle_count ++;
#endif

  // start next cycle
  CLK_E_LOW;    // E goes low

  // natural delay for DATA Hold time (t_HR)
  DATA_DIR = DIR_IN;

  // Background tasks
  r6530_timer_tick();


}

////////////////////////////////////////////////////////////////////
// Serial Event
////////////////////////////////////////////////////////////////////

/*
  SerialEvent occurs whenever a new data comes in the
 hardware serial RX.  This routine is run between each
 time loop() runs, so using delay inside loop can delay
 response.  Multiple bytes of data may be available.
 */
void serialEvent0() 
{
  if (Serial.available())
  {
    // [R]eset
    //
    if ((Serial.peek() == 'R') || (Serial.peek() == 'r'))
    {
      Serial.read();          // take 'r' out of the queue
      uP_assert_reset();
      // delay 250ms so uP sees RESET asserted.
      delay(500 + 2000*outputDEBUG);
      uP_release_reset();
    } 
    else
    // [S]top - NMI
    //
    if ((Serial.peek() == 'S') || (Serial.peek() == 's'))
    {
      Serial.read();          // take 'r' out of the queue
      uP_assert_nmi();
      // delay 250ms so uP sees RESET asserted.
      delay(500 + 2000*outputDEBUG);
      uP_release_nmi();
    } 
    else
    if ((reg002_A & 0x80) == 0)         // reg002_A bit 8 is 0; we can push the char.
    {
      // cli();    
      char ch = toupper(Serial.read());
      reg002_A = ch | 0x80;
      // sei();        
      Serial.write(ch);
    }
  }
}



////////////////////////////////////////////////////////////////////
// int getKey() - LCD/Keyboard function from vendor
////////////////////////////////////////////////////////////////////

int getKey()
{
  key = get_key2();
  if (key != oldkey)
    {
      delay(BTN_DEBOUNCE);
      key = get_key2();
      if (key != oldkey) {
        oldkey = key;
        if (key == -1)
          BTN_RELEASE = 1;
        else
          BTN_PRESS = 1;
      }
    } else {
      BTN_PRESS = 0;
      BTN_RELEASE = 0;
    }
  return (key != -1);
}

int get_key2()
{
  int k;
  int adc_key_in;

  adc_key_in = analogRead( LCD_BTN );
  for( k = 0; k < NUM_KEYS; k++ )
  {
    if ( adc_key_in < adc_key_val[k] )
    {
      return k;
    }
  }
  if ( k >= NUM_KEYS )
    k = -1;
  return k;
}

////////////////////////////////////////////////////////////////////
// Button Press Callbacks - LCD/Keyboard function from vendor
////////////////////////////////////////////////////////////////////

void btn_Pressed_Select()
{
  // toggle LCD brightness
  analogWrite(LCD_BL, (backlightSet = (25 + backlightSet) % 100) );
}

void btn_Pressed_Left()
{
  // Serial.println("Left.");
  digitalWrite(uP_NMI_N, LOW);
}

void btn_Pressed_Right()
{
  // Serial.println("Right.");
  digitalWrite(uP_NMI_N, HIGH);
}

void btn_Pressed_Up()
{
  // Serial.println("Up.");
  
  // release uP_RESET
  digitalWrite(uP_RESET_N, HIGH);
}

void btn_Pressed_Down()
{
  // Serial.println("Down.");
  
  // assert uP_RESET
  digitalWrite(uP_RESET_N, LOW);
  
  // flush serial port
  while (Serial.available() > 0)
    Serial.read();
}


////////////////////////////////////////////////////////////////////
// Setup
////////////////////////////////////////////////////////////////////

void setup() 
{

  Serial.begin(115200);
  
  if (USE_LCDKEYPAD)
  {
    pinMode(LCD_BL, OUTPUT);
    analogWrite(LCD_BL, backlightSet);  
    lcd.begin(16, 2);
  }

  // Initialize processor GPIO's
  uP_init();
  r6530_init();
  kim_init();
  
  // Set up timer1 interrupt to handle clock & addr/data in the fastest possible way.
  // timer interrupt also runs in parallel with the loop() function, so we have a
  // simple multi-threading going on :)
  
  cli();
  //set timer1 interrupt at 1Hz
  TCCR1A = 0;// set entire TCCR1A register to 0
  TCCR1B = 0;// same for TCCR1B
  TCNT1  = 0;//initialize counter value to 0
  if (!outputDEBUG)
  {
    // 100 kHz
    // set compare match register for 1hz increments
    OCR1A = 30; // 100kHz mode: 19;  // = (16*10^6) / (1*1024) - 1 (must be <65536)
    // turn on CTC mode
    TCCR1B |= (1 << WGM12);
    // Set CS10 and CS12 bits for 1024 prescaler
    // CS12 - CS11 - CS10 Prescalar
    // 1=1/1, 2=1/8, 3=1/64, 4=1/256, 5=1/1024
    TCCR1B |=  (1 << CS11);  // ((1<< CS12) | (1 << CS10)); //         
  } else {
    OCR1A = 500;
    TCCR1B |= (1 << WGM12);
    TCCR1B |=  ((1<< CS12) | (1 << CS10)); //         
  }
  // enable timer compare interrupt
  TIMSK1 |= (1 << OCIE1A);
  sei();

  // delay 250ms so uP sees RESET asserted.
  delay(500 + 2000*outputDEBUG);
  
  // Go, go, go
  uP_release_reset();
}


////////////////////////////////////////////////////////////////////
// Loop()
// * This function runs in parallel with timer interrupt handler.
//   i.e. simplest multi-threading.
// * try to be done as quickly as possible so processor does not
//   slow down.
////////////////////////////////////////////////////////////////////

void loop()
{
  if (USE_LCDKEYPAD)
  {

    // Handle key presses
    //
    if ( getKey() ) {
      // button pressed
      if ( BTN_PRESS ) {
        if (key == BTN_SELECT) btn_Pressed_Select();
        if (key == BTN_UP)     btn_Pressed_Up();
        if (key == BTN_DOWN)   btn_Pressed_Down();
        if (key == BTN_LEFT)   btn_Pressed_Left();
        if (key == BTN_RIGHT)  btn_Pressed_Right();      
      }
    } else
    // display processor info & performance
    // if (clock_cycle_count % 10 == 0) 
    {
      char tmp[20];
      float freq;
        
      lcd.setCursor(0, 0);
      // lcd.print(clock_cycle_count);
      sprintf(tmp, "A=%0.4X D=%0.2X", uP_ADDR, DATA_OUT);
      lcd.print(tmp);
      lcd.setCursor(0,1);
      freq = (float) clock_cycle_count / (millis() - uP_start_millis + 1);
      lcd.print(freq);  lcd.print(" kHz  6502 ");
    }
  }
  
  serialEvent0();
    
}